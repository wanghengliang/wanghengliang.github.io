<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hengliang</title>
    <description>快乐地创造和品味生活</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 07 Jan 2019 17:16:53 +0800</pubDate>
    <lastBuildDate>Mon, 07 Jan 2019 17:16:53 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>Java_m</title>
        <description>&lt;h3 id=&quot;选择题&quot;&gt;选择题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下面对JVM叙述不正确的是：（） &lt;br /&gt;
A JVM的全称是Java Virtual Machine &lt;br /&gt;
B JVM是一种计算机硬件技术，它是Java程序的运行平台 &lt;br /&gt;
C JVM是在计算机硬件系统上用软件实现的一台假想机 &lt;br /&gt;
D Java程序在执行时．JVM把Java字节码解释成机器码&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;以下代码执行的结果显示是多少（）？
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
 public static void main(String args[]){
     Demo inc = new Demo();
     int i = 0;
     inc.fermin(i);
     i = i++;
     System.out.println((i++)+&quot; &quot;+i);
 }
 void fermin(int i){
     i++;
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、0 0    B、0 1    C、1 2    D、2 3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
 public static void main(String args[]){
     int count = 0;
     int num = 0;
     for(int i=0;i&amp;lt;=100;i++){
         num = num+i;
         count = count++;
     }
     System.out.println(num*count);
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、505000    B、0    C、运行时错误     D、5050&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于下面的程序，哪一个选项是正确的输出结果（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
 public static void main(String args[]){
     String classFile = &quot;com.scmdkj.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;;
     System.out.println(classFile);
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、///////////MyClass.class&lt;br /&gt;
B、com.scmdkj&lt;br /&gt;
C、com/scmdkj/MyClass/class&lt;br /&gt;
D、com/scmdkj/MyClass.class&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于下面的程序，说法正确的是（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
 static String x = &quot;1&quot;;
 static int y = 1;
 public static void main (String[] args) {
     static int z= 2;
     System.out.println(x+y+z);
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、3    B、112    C、13     D、程序有编译错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;有关下述Java代码描述正确的选项是（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
 private static void testMethod(){
     System.out.println(&quot;testMethod&quot;);
 }
 public static void main(String[] args) {
     ((Demo)null).testMethod();
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、编译不通过&lt;br /&gt;
B、编译通过，运行异常，报NullPointerException&lt;br /&gt;
C、编译通过，运行异常，报NoSuchMethodException&lt;br /&gt;
D、运行正常，输出testMethod&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下关于final关键字说法错误的是（）&lt;br /&gt;
A、final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性&lt;br /&gt;
B、final修饰的类肯定不能被继承&lt;br /&gt;
C、final修饰的方法不能被重载&lt;br /&gt;
D、final修饰的变量不允许被再次赋值&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在使用super和this关键字时，以下描述正确的是（）&lt;br /&gt;
A、在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过&lt;br /&gt;
B、super（）和this（）不一定要放在构造方法内第一行&lt;br /&gt;
C、this（）和super（）可以同时出现在一个构造函数中&lt;br /&gt;
D、this（）和super（）可以在static环境中使用，包括static方法和static语句块&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;对于如下代码段,可以放入到横线位置，使程序正确编译运行，而且不产生错误的选项是（ ）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A{
 public A foo(){
     return this;
 }
}
class B extends A{
 public A foo(){
     return this;
 }
}
class C extends B{
 _______
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A. public void foo(){} &lt;br /&gt;
B. public int foo(){return 1;} &lt;br /&gt;
C. public A foo(B b){return b;} &lt;br /&gt;
D. public A foo(){return A;}&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下列哪些针对代码运行结果的描述是正确的？
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Vehicle{
 private final void run(){
     System.out.println(&quot;Vehicle&quot;);
 }
}
public class Car extends Vehicle{
 public static void main (String[] args){
     new Car().run();
 }
 private final void run(){
     System.out.println (&quot;Car&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A. Car &lt;br /&gt;
B. Vehicle &lt;br /&gt;
C. Compiler error &lt;br /&gt;
D. Exception thrown at runtime&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下列程序执行后结果为( )
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A {
 public int func1(int a, int b) {
     return a - b;
 }
}
class B extends A {
 public int func1(int a, int b) {
     return a + b;
 }
}
public class ChildClass {
 public static void main(String[] args) {
 A a = new B();
 B b = new B();
 System.out.println(&quot;Result=&quot; + a.func1(100, 50));
 System.out.println(&quot;Result=&quot; + b.func1(100, 50));
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、 Result=150 Result=150 &lt;br /&gt;
B、 Result=100 Result=100 &lt;br /&gt;
C、 Result=100 Result=150 &lt;br /&gt;
D、 Result=150 Result=100&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;byte[] src,dst;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A dst=String.fromBytes(src，”GBK”).getBytes(“UTF-8”) &lt;br /&gt;
B dst=new String(src，”GBK”).getBytes(“UTF-8”) &lt;br /&gt;
C dst=new String(“GBK”，src).getBytes() &lt;br /&gt;
D dst=String.encode(String.decode(src，”GBK”))，”UTF-8” )&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面输出顺序顺序的是（）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class B extends Object{
 static{
     System.out.println(&quot;Load B&quot;);
 }
 public B(){
     System.out.println(&quot;Create B&quot;);
 }
}
class A extends B{
 static{
     System.out.println(&quot;Load A&quot;);
 }
 public A(){
     System.out.println(&quot;Create A&quot;);
 }
}
public class Testclass{
 public static void main(String[] args){
     new A();
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A. Load B -&amp;gt;Create B-&amp;gt;Load A -&amp;gt; Create A &lt;br /&gt;
B. Load B -&amp;gt; Load A -&amp;gt;Create B -&amp;gt;Create A &lt;br /&gt;
C. Load B -&amp;gt; Create B-&amp;gt; Create A -&amp;gt; Load A &lt;br /&gt;
D. Create B -&amp;gt;Create A -&amp;gt;Load B -&amp;gt;Load A&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下说法错误的是（） &lt;br /&gt;
A 虚拟机中没有泛型，只有普通类和普通方法 &lt;br /&gt;
B 所有泛型类的类型参数在编译时都会被擦除 &lt;br /&gt;
C 创建泛型对象时请指明类型，让编译器尽早的做参数检查 &lt;br /&gt;
D 泛型的类型擦除机制意味着不能在运行时动态获取List中T的实际类型&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请问所有的异常类皆直接继承于哪一个类？（） &lt;br /&gt;
A java.applet.Applet &lt;br /&gt;
B java.lang.Throwable &lt;br /&gt;
C java.lang.Exception &lt;br /&gt;
D java.lang.Error&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面函数将返回（）&lt;br /&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int func (){
 try{
     return 1;
 }catch (Exception e){
     return 2;
 }finally{
     return 3;
 }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A、1     B、2     C、3     D、编译错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下列不属于WebService 涉及到的主要标准和技术的是___&lt;br /&gt;
A、XML    B、SOAP    C、WSDL      D、JAVA&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下列不属于WebService 特征的是___&lt;br /&gt;
A. WebService具有良好的封装性&lt;br /&gt;
B. WebService与使用者是松散耦合的&lt;br /&gt;
C. WebService具有高度的可集成性&lt;br /&gt;
D. WebService使用的协议非常简单，通常可以自行解析，不需要使用第三方的库&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面关于spring描述错误的是：（ ）&lt;br /&gt;
A  Spring支持可插入的事务管理器，使事务划分更轻松，同时无需处理底层的问题。&lt;br /&gt;
B  Spring事务管理的通用抽象层还包括JTA策略和一个JDBC DataSource。&lt;br /&gt;
C  与JTA或EJB CMT一样，Spring的事务支持依赖于Java EE环境。&lt;br /&gt;
D  Spring事务语义通过AOP应用于 POJO，通过XML或Java SE 5注释进行配置。&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法错误的是（  ）？&lt;br /&gt;
A. 它负责接收HTTP请求&lt;br /&gt;
B. 加载配置文件&lt;br /&gt;
C. 实现业务操作&lt;br /&gt;
D. 初始化上下应用对象ApplicationContext&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;多选题&quot;&gt;多选题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;（多选题）true、false、null、sizeof、goto、synchronized 哪些是Java关键字（）&lt;br /&gt;
A、true    B、false    C、null     D、sizeof      E、goto     F、synchronized&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;（多选题）类Parent和Child定义如下，对于如下代码段，可以放入到横线位置，使程序正确编译运行，而且不产生错误的选项是（ ）
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Parent{
 public float aFun(float a, float b){return a+b;}
}
class Child extends Parent{
 _______
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;A. float aFun(float a, float b){return a+b;} &lt;br /&gt;
B. public int aFun(int a, int b){return a+b;} &lt;br /&gt;
C. public float aFun(float a, float b){return a+b;} &lt;br /&gt;
D. private int aFun(int a, int b){return a+b;}&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（多选题）常用的servlet包的名称是？（） &lt;br /&gt;
A java.servlet &lt;br /&gt;
B javax.servlet &lt;br /&gt;
C servlet.http &lt;br /&gt;
D javax.servlet.http&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（多选题）下面有关forward和redirect的描述，正确的是() ？ &lt;br /&gt;
A forward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求 &lt;br /&gt;
B 执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址 &lt;br /&gt;
C 执行redirect时，服务器端告诉浏览器重新去请求地址 &lt;br /&gt;
D forward是内部重定向，redirect是外部重定向 &lt;br /&gt;
E redirect默认将产生301 Permanently moved的HTTP响应&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;（多选题）JAVA反射机制主要提供了以下哪些功能？（）&lt;br /&gt;
A 在运行时判断一个对象所属的类 &lt;br /&gt;
B 在运行时构造一个类的对象 &lt;br /&gt;
C 在运行时判断一个类所具有的成员变量和方法 &lt;br /&gt;
D 在运行时调用一个对象的方法&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;简述题&quot;&gt;简述题&lt;/h3&gt;

&lt;p&gt;表结构&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE `TBL_ORDER`(
	`ID` INT(11) AUTO_INCREMENT,
	`USER_ID` INT(11) COMMENT '用户',
	`CODE` VARCHAR(32) COMMENT '订购结果编码 0-成功，999-失败，998-用户取消',
	`CHANNEL_ID` INT(11) COMMENT '栏目id',
	`CREATE_TIME` TIMESTAMP COMMENT '统计时间',
	PRIMARY KEY(`ID`)
)

CREATE TABLE `TBL_USER`(
	`ID` INT(11) AUTO_INCREMENT,
	`USER_NAME` VARCHAR(32) COMMENT '用户登录名',
	`TEL` VARCHAR(11) COMMENT '电话号码',
	`USER_IP` VARCHAR(50) COMMENT '用户IP',
	PRIMARY KEY(`ID`)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;统计用户人数？
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;统计订购成功、订购失败、用户退出订购人数？
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询昨天订购成功的用户信息？
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;以下js代码会出现什么情况？在什么地方显示？显示结果是什么？
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(1 &amp;amp;&amp;amp; 2 || 0);
console.log(0 || 2 &amp;amp;&amp;amp; 1);
console.log(0 &amp;amp;&amp;amp; 2 || 1);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;编写一个方法 去掉一个数组的重复元素
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;应用题&quot;&gt;应用题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;用js写一个拼图游戏（3x3或可配置）,要求如下：&lt;br /&gt;
1、通过键盘&lt;code class=&quot;highlighter-rouge&quot;&gt;方向键&lt;/code&gt;进行选择拼块&lt;code class=&quot;highlighter-rouge&quot;&gt;确定键&lt;/code&gt;进行移动，无法移动拼块进行&lt;code class=&quot;highlighter-rouge&quot;&gt;此拼块无法移动&lt;/code&gt;提示&lt;br /&gt;
2、进入游戏后可观察3秒原图后自动打乱拼图&lt;br /&gt;
3、拼图成功后可通过回调函数进行自定义成功后续操作&lt;br /&gt;
4、加入倒计时，5分钟无法完成游戏给出&lt;code class=&quot;highlighter-rouge&quot;&gt;拼图失败&lt;/code&gt;提示&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 07 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/java_m/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/java_m/</guid>
        
        
      </item>
    
      <item>
        <title>页面事件处理</title>
        <description>&lt;p&gt;页面事件处理&lt;/p&gt;

&lt;h3 id=&quot;关于keypress和keydown事件的区别和联系&quot;&gt;关于KeyPress和KeyDown事件的区别和联系&lt;/h3&gt;

&lt;h4 id=&quot;keypress主要用来监听键盘输出的字符&quot;&gt;KeyPress主要用来监听键盘输出的「字符」&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;KeyPress在控件有焦点的情况下按下键时发生。&lt;/li&gt;
  &lt;li&gt;KeyPress只能捕获单个字符。&lt;/li&gt;
  &lt;li&gt;KeyPressKeyPress主要用来捕获数字(注意：包括Shift+数字的符号)、字母（注意：包括大小写）、ANSI字符（注意:只能捕获除了F1-12、SHIFT、Alt、Ctrl、Insert、Home、PgUp、Delete、End、PgDn、ScrollLock、Pause、NumLock、{菜单键}、{开始键}和方向键外的ANSI字符，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;等）.&lt;/li&gt;
  &lt;li&gt;KeyPress不显示键盘的物理状态（SHIFT键），而只是传递一个字符,KeyPress 将每个字符的大、小写形式作为不同的键代码解释，即作为两种不同的字符，（区分大小写）。&lt;/li&gt;
  &lt;li&gt;KeyPress 不区分小键盘和主键盘的数字字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;keydown主要用来监听键盘输出的功能&quot;&gt;KeyDown主要用来监听键盘输出的「功能」&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;KeyDown在控件有焦点的情况下按下键时发生。&lt;/li&gt;
  &lt;li&gt;KeyDown可以捕获组合键。&lt;/li&gt;
  &lt;li&gt;KeyDown事件过程通常可以捕获键盘上除了PrScrn（在键盘右上角）之外的所有按键(这里不讨论特殊键盘的特殊键）&lt;/li&gt;
  &lt;li&gt;KeyDown不能判断键值字母的大小写（可通过SHIFT键状态判断）。&lt;/li&gt;
  &lt;li&gt;KeyDown区分小键盘和主键盘的数字字符。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;keyup主要用来监听键盘输出的功能&quot;&gt;KeyUp主要用来监听键盘输出的「功能」&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;KeyUp在控件有焦点的情况下释放键时发生。&lt;/li&gt;
  &lt;li&gt;KeyUp可以捕获组合键。&lt;/li&gt;
  &lt;li&gt;KeyUp事件过程通常可以捕获键盘上除了PrScrn（在键盘右上角）之外的所有按键(这里不讨论特殊键盘的特殊键）&lt;/li&gt;
  &lt;li&gt;KeyUp不能判断键值字母的大小写（可通过SHIFT键状态判断）。&lt;/li&gt;
  &lt;li&gt;KeyUp区分小键盘和主键盘的数字字符。&lt;/li&gt;
  &lt;li&gt;要判断key修改后的状态必须用KeyUp（如：同步一个输入框内容到span中，keypress和keydown总是少最后一个字符，keyup才能完整同步）。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 23 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/js_event/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/js_event/</guid>
        
        <category>Javascript</category>
        
        <category>前端</category>
        
        
        <category>技术开发</category>
        
      </item>
    
      <item>
        <title>MacOS动态壁纸制作</title>
        <description>&lt;p&gt;MacOS动态壁纸制作&lt;/p&gt;

&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;macOS 10.14 (Mojave)的一项用户界面的新功能——动态桌面（dynamic desktop）受到的关注则少得多。这是一项默认关闭的功能，启用方法是打开「系统偏好设置 - 桌面与屏幕保护程序」，从「动态桌面」中选择系统自带的两套壁纸之一。&lt;/p&gt;

&lt;p&gt;乍听起来，这确实并不稀奇，也没有任何技术门槛。随时间变化切换壁纸是很多桌面美化软件的基础功能，更别提十多年前的 Windows Vista 就已经原生支持 视频壁纸 了。&lt;/p&gt;

&lt;p&gt;但问题实际上并不只是 「按时间切换图片」 这么简单。因为，晨昏变化的节奏并非一成不变，而是随着四季变换各有不同。除非生活在赤道或者极地，从夏到冬一定是昼渐短、夜渐长的。如果全年都按照一个节拍切换壁纸，其效果在绝大多数日子里都将跟真实景象不同步。&lt;/p&gt;

&lt;p&gt;随着季节推移变化的不只是昼夜长度，还有 太阳高度 。显然，夏天的太阳比冬天的同一时间要「高」。太阳高度还与纬度有关。假如你生活在北京，而系统在中午时分给你换上了一张「阳光从头顶直射」的壁纸，你其实应该有一种违和感才对，因为北京根本不会有 90 度的日照。地处北纬 40 度的北京，太阳最高也只能达到 73.5 度，并且一年只有一次，时间是在夏至那天的（地方时）正午。&lt;/p&gt;

&lt;p&gt;可见，要真正让桌面和窗外的光照 同步 变化，机械地踩着时间点换图片是远远不够的。理想情况下，同一组图片的切换节奏应当呼应太阳运动、在四季各不相同，并且根据用户的地理位置和日期，有选择地「跳过」一些不符合实际情况的照片。&lt;/p&gt;

&lt;h3 id=&quot;动态桌面的实现机制&quot;&gt;动态桌面的实现机制&lt;/h3&gt;

&lt;p&gt;macOS Mojave 的动态桌面充分考虑了上述问题。在苹果的实现方案中，壁纸的切换不是以时间为标准，而是以 太阳方位 为标准。具体而言：&lt;/p&gt;

&lt;p&gt;每套壁纸包含 16 张静态图片（实验表明似乎可以更少，但不能更多）。
每张静态图片都被标记了对应的太阳方位。定位的方式是所谓的 「地平坐标系」 ，即用高度角（Altitude，定义为太阳和地平线的夹角）和方位角（Azimuth，定义为太阳按顺时针方向偏离正北的角度）两个值确定太阳在天球中的位置。
启用后，系统将会根据用户的位置和时间计算太阳的实时方位，并与每张壁纸所记载的信息进行比对，将其中与此时此地太阳位置最近似的那一张作为桌面背景。&lt;/p&gt;

&lt;p&gt;地平面坐标系图示如下：&lt;/p&gt;

&lt;p&gt;实际例子可能更有助于理解动态桌面的机制。我目前的所在地处于北纬 40 度，与北京基本相同。10 月 5 日的早上 6:30 尚未日出，此时的太阳高度为 -6.75 度，方位为 90.6 度。启用「沙丘」动态壁纸后，桌面显示为该系列中的第三张。根据壁纸的元信息（后文将说明方法），这张照片是在太阳高度 -4.25 度，方位 86.34 度的场景下拍摄的，与现实环境非常接近。如果将系统日期拨回三个月前的 7 月 5 日，会发现壁纸变成了系列中的第五张（太阳高度为 7 度）。的确，夏天的这一时刻，太阳应该已经升起了。&lt;/p&gt;

&lt;p&gt;再将日期调回 10 月 5 日。这一天，太阳在下午 12:48 时达到最高位置。但如果试着慢慢将时钟调过这一时刻，会发现壁纸并没有切换为系列中最明亮的第八张，而是直接从第七张跳到了第九张。原因在于，秋天的太阳即使在正午也只能达到 45 度左右，而第八张壁纸是在太阳处于 53 度时拍摄的，因此不会被显示。相反，在 Mojave 刚刚开始公测的七月时，这张壁纸会从上午 10:40 左右开始持续显示约五个小时。&lt;/p&gt;

&lt;p&gt;更有趣的是，在另一套动态壁纸 Solar Gradients 中，一张图片对应的太阳高度为 88.4 度。如上所述，由于北纬 40 度的太阳全年最高也只能达到 73.5 度，我将始终不会看到这张最亮的壁纸被用作桌面——它实际上成了热带地区用户的「会员特权」。&lt;/p&gt;

&lt;h3 id=&quot;壁纸资源技术细节与自制方法&quot;&gt;壁纸资源、技术细节与自制方法&lt;/h3&gt;

&lt;p&gt;将动态壁纸的配置信息转为可读模式，这样，苹果在 Mojave 的动态壁纸中设置的机关就展现出全貌了。可以看到，在 si 根键下，每张静态图片被都标记了 i 、 a 、 z 三个键值，分别对应照片的序号、拍摄时的太阳高度角和方位角。&lt;/p&gt;

&lt;p&gt;此外，沙丘壁纸还有一个 ap 根键，其下的 l 和 d 两个值分别指定了在设置中启用亮暗两种「静态」选项时，要显示的图片序号。（太阳渐变壁纸没有 ap 根键，因此在设置中没有「静态」选项。）&lt;/p&gt;

&lt;p&gt;至此，原理上的铺垫就全部完成了，最后要解决的就是如何据此自行制作动态壁纸。显然，这涉及到格式转换、信息编码等操作，全部手工完成会非常繁琐。好在，已经有开发者制作出了 &lt;a href=&quot;https://github.com/mczachurski/wallpapper&quot;&gt;命令行工具&lt;/a&gt; ，可以使用 Homebrew 安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew tap mczachurski/wallpapper &amp;amp;&amp;amp; brew install wallpapper
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里简单介绍一下该工具的使用方法。首先，将想要制作成动态壁纸的图片文件按序号依次命名。然后在 同一目录 下创建一个 JSON 文件（如 config.json ），在其中逐行指定照片的参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
{&quot;fileName&quot;:&quot;1.png&quot;,&quot;isPrimary&quot;:false,&quot;isForLight&quot;:false,&quot;isForDark&quot;:false,&quot;altitude&quot;:-0.34275283875350282,&quot;azimuth&quot;:270.9334057827345},
…
{&quot;fileName&quot;:&quot;16.png&quot;,&quot;isPrimary&quot;:false,&quot;isForLight&quot;:false,&quot;isForDark&quot;:false,&quot;altitude&quot;:-38.04743388682423,&quot;azimuth&quot;:53.509085812513092}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中， fileName 为文件名， isPrimary 表示是否将图片用作记录整套壁纸元信息的「首要图片」， isForLight 和 isForDark 分别指是否用作开启亮/暗两种「静态」选项时使用的图片， altitude 和 azimuth 则是照片对应的高度角和方位角。&lt;/p&gt;

&lt;p&gt;准备完毕后，在终端执行 wallpapper -i config.json 即可获得打包好的 HEIC 格式动态壁纸。&lt;/p&gt;

&lt;p&gt;想要省事的读者也可以使用此 &lt;a href=&quot;https://cl.ly/1b0449fdfb89/dynwp-config-sample.json&quot;&gt;模板配置文件&lt;/a&gt; ，其内容原样复制了系统自带的沙丘壁纸中图片的参数，只需找 16 张光线情况与该套壁纸类似的图片，依次命名为 1.png 到 16.png ，并用上述工具制作即可。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://sspai.com/post/47390&quot;&gt;macOS Mojave 的动态桌面，可不只是「定时换壁纸」这么简单&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 06 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/macos_wallpapper/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/macos_wallpapper/</guid>
        
        <category>MacOS</category>
        
        
        <category>MacOS</category>
        
      </item>
    
      <item>
        <title>JAVA异常处理</title>
        <description>&lt;p&gt;JAVA异常处理&lt;/p&gt;

&lt;p&gt;要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：&lt;/p&gt;

&lt;p&gt;检查性异常: 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。&lt;/p&gt;

&lt;p&gt;运行时异常: 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。&lt;/p&gt;

&lt;p&gt;错误: 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/java/java-exceptions.html&quot;&gt;Java 异常处理&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/java_exception/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/java_exception/</guid>
        
        <category>JAVA</category>
        
        <category>异常</category>
        
        
        <category>技术开发</category>
        
      </item>
    
      <item>
        <title>jekyll整合MathjaxJS插入数学公式</title>
        <description>&lt;p&gt;jekyll整合MathjaxJS插入数学公式&lt;/p&gt;

&lt;h3 id=&quot;mathjax简介&quot;&gt;MathJax简介&lt;/h3&gt;

&lt;p&gt;MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。(Wiki)&lt;/p&gt;

&lt;p&gt;先给几个效果看看&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x^{y^z}=(1+{\rm e}^x)^{-2xy^w}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sideset{^1_2}{^3_4}\bigotimes&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f\left(
   \left[ 
     \frac{
       1+\left\{x,y\right\}
     }{
       \left(
          \frac{x}{y}+\frac{y}{x}
       \right)
       \left(u+1\right)
     }+\sqrt{a} \quad
   \right]^{3/2}
\right)&lt;/script&gt;

&lt;h3 id=&quot;引入mathjax&quot;&gt;引入MathJax&lt;/h3&gt;

&lt;p&gt;在页脚处，引入官方的cdn,但这个js还是会调用到 cdn.mathjax.org 里的一些配置js文件，我们最好在head内加一个dns-prefetch，用于网页加速&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//head中引入
&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.mathjax.org&quot; /&amp;gt;

//页脚处引入
&amp;lt;script src=&quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;官方cdn的js在国内访问慢，所以我们一般引入的是国内的公共资源cdn提供的js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//head中引入
&amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cdn.bootcss.com&quot; /&amp;gt;

//页脚处引入
&amp;lt;script src=&quot;//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jekyll中找到自己的模板中相应位置添加以上代码即可。&lt;/p&gt;

&lt;h3 id=&quot;mathjax的config说明&quot;&gt;MathJax的config说明&lt;/h3&gt;

&lt;p&gt;其config包括外联config和内联config。&lt;/p&gt;

&lt;h4 id=&quot;外联config说明&quot;&gt;外联config说明&lt;/h4&gt;

&lt;p&gt;我们引入MathJax，发现链接后面多了个?config=TeX-AMS-MML_HTMLorMML这个多出来的东西其实是告诉MathJax，我们要用到的叫TeX-AMS-MML_HTMLorMML.js的配置文件，其用来控制显示数学公式的HTMl显示输出。&lt;/p&gt;

&lt;h4 id=&quot;内联config说明&quot;&gt;内联config说明&lt;/h4&gt;

&lt;p&gt;与此同时，官方其实还提供了一个能让我们内联一个配置选项的功能，很简单就是使用&lt;script&gt;&lt;/script&gt;标签对，但注意的是需要声明类型type=”text/x-mathjax-config”。要想让这个内联配置生效就得放在MathJax.js之前，例子如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt;
MathJax.Hub.Config({
});
&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中MathJax.Hub.Config()里的配置选项很多，可以查看官网说明，这里不详细说明，只给出我用的，并给出一些说明&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/x-mathjax-config&quot;&amp;gt;
var mathId = document.getElementById(&quot;post-container&quot;);//选择公式识别范围
MathJax.Hub.Config({
    showProcessingMessages: false,//关闭js加载过程信息
    messageStyle: &quot;none&quot;,//不显示信息
    extensions: [&quot;tex2jax.js&quot;],
    jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
    tex2jax: {
        inlineMath:  [ [&quot;$&quot;, &quot;$&quot;] ],//行内公式选择符
        displayMath: [ [&quot;$$&quot;,&quot;$$&quot;] ],//段内公式选择符
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'],//避开某些标签
        ignoreClass:&quot;comment-content&quot; //避开含该Class的标签
    },
    &quot;HTML-CSS&quot;: {
        availableFonts: [&quot;STIX&quot;,&quot;TeX&quot;],//可选字体
        showMathMenu: false //关闭右击菜单显示
    }
});
MathJax.Hub.Queue([&quot;Typeset&quot;,MathJax.Hub,mathId]);//选择公式识别范围
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;数学公式识别&quot;&gt;数学公式识别&lt;/h4&gt;
&lt;p&gt;通过tex2jax中的inlineMath和displayMath进行数学公式识别，&lt;/p&gt;

&lt;p&gt;其中inlineMath识别的单行内的数学公式,我们可以通过$ … $或\( … \)去识别这种数学公式，&lt;/p&gt;

&lt;p&gt;displayMath就是识别整个独立段落的数学公式并且居中显示,我们可以通过&lt;script type=&quot;math/tex&quot;&gt;...&lt;/script&gt;或\[ … \]去识别这种数学公式&lt;/p&gt;

&lt;h4 id=&quot;约束识别范围&quot;&gt;约束识别范围&lt;/h4&gt;
&lt;p&gt;默认情况下,MathJax.Hub.Queue([“Typeset”,MathJax.Hub])是对整个DOM树进行识别的，我们要约束识别范围，官方文档告诉我们MathJax.Hub.Queue的第三个参数就是识别范围，上面的代码就是告诉我们要在id为post-container的标签内去做公式识别&lt;/p&gt;

&lt;h4 id=&quot;避开特殊标签和class&quot;&gt;避开特殊标签和Class&lt;/h4&gt;
&lt;p&gt;其中skipTags用来避开一些特殊的标签内的内容，这里避开是script,noscript,style,textarea,pre,code,a标签&lt;/p&gt;

&lt;p&gt;ignoreClass用来避开标签内声明的CSS Class属性，这里避开的是带有class=”comment-content”的标签，如果我们不想让mathjax识别评论里的公式就可以用ignoreClass，如果有多个Class需要避开，我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 来区分，写成&lt;code class=&quot;highlighter-rouge&quot;&gt;ignoreClass: &quot;class1|class2&quot;&lt;/code&gt;就可以了&lt;/p&gt;

&lt;h3 id=&quot;公式使用&quot;&gt;公式使用&lt;/h3&gt;

&lt;h4 id=&quot;1-如果插入公式&quot;&gt;1. 如果插入公式&lt;/h4&gt;

&lt;h4 id=&quot;2-如何输入上下标&quot;&gt;2. 如何输入上下标&lt;/h4&gt;

&lt;h4 id=&quot;3-如何输入括号和分隔符&quot;&gt;3. 如何输入括号和分隔符&lt;/h4&gt;

&lt;h4 id=&quot;4-如何输入分数&quot;&gt;4. 如何输入分数&lt;/h4&gt;

&lt;h4 id=&quot;5-如何输入开方&quot;&gt;5. 如何输入开方&lt;/h4&gt;

&lt;h4 id=&quot;6-如何输入省略号&quot;&gt;6. 如何输入省略号&lt;/h4&gt;

&lt;h4 id=&quot;7-如何输入矢量&quot;&gt;7. 如何输入矢量&lt;/h4&gt;

&lt;h4 id=&quot;8-如何输入积分&quot;&gt;8. 如何输入积分&lt;/h4&gt;

&lt;h4 id=&quot;9如何输入极限运算&quot;&gt;9.如何输入极限运算&lt;/h4&gt;

&lt;h4 id=&quot;10如何输入累加累乘运算&quot;&gt;10.如何输入累加、累乘运算&lt;/h4&gt;

&lt;h4 id=&quot;11如何输入希腊字母&quot;&gt;11.如何输入希腊字母&lt;/h4&gt;

&lt;h4 id=&quot;12大括号和行标的使用&quot;&gt;12.大括号和行标的使用&lt;/h4&gt;

&lt;h3 id=&quot;参考内容&quot;&gt;参考内容&lt;/h3&gt;
&lt;p&gt;本文内容参考一下网页内容&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.linpx.com/p/front-end-integration-mathjaxjs-configuration.html&quot;&gt;前端整合MathjaxJS的配置笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/q735613050/p/7253073.html&quot;&gt;Markdown公式编辑学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/7474449.html&quot;&gt;Markdown公式（二）&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/MathjaxJS/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/MathjaxJS/</guid>
        
        <category>jekyll</category>
        
        <category>mathjaxJs</category>
        
        
        <category>技术开发</category>
        
      </item>
    
      <item>
        <title>java位运算</title>
        <description>&lt;p&gt;java位运算&lt;/p&gt;

&lt;p&gt;位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数进行位运算。位运算符可以分为逻辑运算符(包括&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;＆&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;)及移位运算符(包括&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;)。&lt;/p&gt;

&lt;h3 id=&quot;二进制表示&quot;&gt;二进制表示&lt;/h3&gt;

&lt;p&gt;二进制第一位为符号位，0表示正数，1表示负数。&lt;/p&gt;

&lt;h4 id=&quot;1正数表示例如int类型值-5int用32位表示&quot;&gt;1.正数表示,例如:int类型值 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;(int用32位表示)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5 = 0000 0000 0000 0000 0000 0000 0000 0101
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2负数表示例如int类型值--5&quot;&gt;2.负数表示,例如:int类型值 &lt;code class=&quot;highlighter-rouge&quot;&gt;-5&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-5 = 1111 1111 1111 1111 1111 1111 1111 1011
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;负数二进制表示方法如下：&lt;/p&gt;

&lt;p&gt;首先来个正数5&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5 = 0000 0000 0000 0000 0000 0000 0000 0101
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个就是&lt;code class=&quot;highlighter-rouge&quot;&gt;原码&lt;/code&gt;，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;原码&lt;/code&gt;取反（0的变成1，1的变成0），得到&lt;code class=&quot;highlighter-rouge&quot;&gt;反码&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原码: 0000 0000 0000 0000 0000 0000 0000 0101
反码: 1111 1111 1111 1111 1111 1111 1111 1010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;反码&lt;/code&gt;进行加1得到&lt;code class=&quot;highlighter-rouge&quot;&gt;补码&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原码: 0000 0000 0000 0000 0000 0000 0000 0101
反码: 1111 1111 1111 1111 1111 1111 1111 1010
补码: 1111 1111 1111 1111 1111 1111 1111 1011
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最终得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;补码&lt;/code&gt;就是负数在计算机中的二进制表示方法&lt;/p&gt;

&lt;h4 id=&quot;3二进制转换为十进制&quot;&gt;3.二进制转换为十进制&lt;/h4&gt;

&lt;p&gt;正数不讲,略…, 这里只说负数，先随便来一个负数二进制&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;负数二进制: 1111 1111 1111 1111 1111 1111 1111 1011
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;负数二进制，减1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;负数二进制: 1111 1111 1111 1111 1111 1111 1111 1011
二进制减一: 1111 1111 1111 1111 1111 1111 1111 1010
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;取反&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;负数二进制: 1111 1111 1111 1111 1111 1111 1111 1011
二进制减一: 1111 1111 1111 1111 1111 1111 1111 1010
减一后取反: 0000 0000 0000 0000 0000 0000 0000 0101
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后计算得到结果为5，那么负数二进制就为-5&lt;/p&gt;

&lt;h3 id=&quot;逻辑运算符&quot;&gt;逻辑运算符&lt;/h3&gt;

&lt;h4 id=&quot;1非运算--取反&quot;&gt;1.非(&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;)运算	: 取反&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(~5);// 结果为-6 

5  = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
~5 = 1111 1111 1111 1111 1111 1111 1111 1010 = -6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2与-运算--有0出0全1出1&quot;&gt;2.与 (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;)运算	: 有0出0;全1出1&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 &amp;amp; 3);// 结果为1

5     = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
3     = 0000 0000 0000 0000 0000 0000 0000 0011 = 3
5 &amp;amp; 3 = 0000 0000 0000 0000 0000 0000 0000 0001 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3或运算--有1出1全0出0&quot;&gt;3.或(&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;)运算	: 有1出1;全0出0&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 | 3);// 结果为7

5     = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
3     = 0000 0000 0000 0000 0000 0000 0000 0011 = 3
5 | 3 = 0000 0000 0000 0000 0000 0000 0000 0111 = 7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4异或运算-相同得0相异得1&quot;&gt;4.异或(&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;)运算: 相同得0;相异得1&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 ^ 3);//结果为6 

5     = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
3     = 0000 0000 0000 0000 0000 0000 0000 0011 = 3
5 ^ 3 = 0000 0000 0000 0000 0000 0000 0000 0110 = 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;a小应用&quot;&gt;A.小应用&lt;/h4&gt;

&lt;p&gt;一个数字标识位表示多种逻辑,例如：一个任务可分成n个独立小任务，每个小任务之间不分先后顺序，当所有小任务完成则表示此任务完成。&lt;/p&gt;

&lt;p&gt;如果n=3，则将3个小任务分别用$2^0$,$2^1$,$2^2$即1,2,4表示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//更新当前任务完成第1个小任务
update tbl_task set status = status|1 where id=1;
//同理，更新当前任务完成第2个小任务
update tbl_task set status = status|2 where id=1;
//同理，更新当前任务完成第3个小任务
update tbl_task set status = status|4 where id=1;
//当status = 7时，则表示三个任务都完成;

//查询第1个小任务未完成的所有任务
select * from tbl_task where status&amp;amp;1=0;
//查询第1个小任务已完成的所有任务
select * from tbl_task where status&amp;amp;1=1;

//同理，第2个小任务
//查询第2个小任务未完成的所有任务
select * from tbl_task where status&amp;amp;2=0;
//查询第2个小任务已完成的所有任务
select * from tbl_task where status&amp;amp;2=2;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;移位运算符&quot;&gt;移位运算符&lt;/h3&gt;

&lt;h4 id=&quot;1左移位运算符能将运算符左边的运算对象向左移动运算符右侧指定的位数在低位补0&quot;&gt;1.左移位运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 &amp;lt;&amp;lt; 3);// 运行结果是40

5      = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
5 &amp;lt;&amp;lt; 3 = 0000 0000 0000 0000 0000 0000 0010 1000 = 40
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2有符号右移位运算符则将运算符左边的运算对象向右移动运算符右侧指定的位数-有符号右移位运算符使用了符号扩展若值为正则在高位插入0若值为负则在高位插入1&quot;&gt;2.“有符号”右移位运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。 “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 &amp;gt;&amp;gt; 3);// 运行结果是0

5      = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
5 &amp;gt;&amp;gt; 3 = 0000 0000 0000 0000 0000 0000 0000 0000 = 0

System.out.println(-5 &amp;gt;&amp;gt; 3);// 结果是-1

-5      = 1111 1111 1111 1111 1111 1111 1111 1011 = -5
-5 &amp;gt;&amp;gt; 3 = 1111 1111 1111 1111 1111 1111 1111 1111 = -1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3java也添加了一种无符号右移位运算符它使用了零扩展无论正负都在高位插入0这一运算符是c或c没有的&quot;&gt;3.Java也添加了一种“无符号”右移位运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(5 &amp;gt;&amp;gt;&amp;gt; 3);// 结果是0

5       = 0000 0000 0000 0000 0000 0000 0000 0101 = 5
5 &amp;gt;&amp;gt;&amp;gt; 3 = 0000 0000 0000 0000 0000 0000 0000 0000 = 0

System.out.println(-5 &amp;gt;&amp;gt;&amp;gt; 3);// 结果是536870911

-5       = 1111 1111 1111 1111 1111 1111 1111 1011 = -5
-5 &amp;gt;&amp;gt;&amp;gt; 3 = 0001 1111 1111 1111 1111 1111 1111 1111 = 536870911
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 30 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/java_bit_operation/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/java_bit_operation/</guid>
        
        <category>JAVA</category>
        
        
        <category>技术开发</category>
        
      </item>
    
      <item>
        <title>Linux使用技巧</title>
        <description>&lt;p&gt;Linux使用技巧&lt;/p&gt;

&lt;h3 id=&quot;单用户登录模式&quot;&gt;单用户登录模式&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重启服务器，在选择内核界面使用上下箭头移动&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择内核并按“e”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到下面这行
&lt;img src=&quot;/images/posts/linux/skill_01_01.png&quot; alt=&quot;&quot; /&gt;
这里要删除掉rhgb quiet，如下图
&lt;img src=&quot;/images/posts/linux/skill_01_02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用“ctrl + x” 来重启服务器就可以了，重启后就会进入到单用户&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;退出单用户命令  exec /sbin/init&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;同步时间&quot;&gt;同步时间&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;安装ntp服务&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install ntp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.加入crontab&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/crontab

## 加入如下内容
* */1 * * * root ntpdate 0.asia.pool.ntp.org
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/linux_skill/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/linux_skill/</guid>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>jmeter压力测试</title>
        <description>&lt;p&gt;jmeter压力测试&lt;/p&gt;

&lt;h3 id=&quot;下载及安装&quot;&gt;下载及安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;登录官网Jmeter下载，得到压缩包apache-jmeter-5.0.tgz，下载地址：http://jmeter.apache.org/download_jmeter.cgi&lt;/li&gt;
  &lt;li&gt;将下载得到的压缩包apache-jmeter-5.0.tgz解压即可。
&lt;img src=&quot;/images/posts/tools/jmeter01.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;

&lt;p&gt;执行bin/jmeter.bat或者bin/jmeter.sh运行，效果图如下
&lt;img src=&quot;/images/posts/tools/jmeter02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一个简单的压测实例&quot;&gt;一个简单的压测实例&lt;/h3&gt;

&lt;h4 id=&quot;新建一个线程组&quot;&gt;新建一个线程组&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;设置线程组参数&quot;&gt;设置线程组参数&lt;/h4&gt;
&lt;p&gt;这里配置为：10个线程，同时启动，循环一次。这些配置元件用于指定运行的线程数和等候周期。每个线程模拟一个用户，而等候周期用于指定创建全部线程的时间。例如，线程数为5，等候时间为10秒，则创建每个线程之间的时间间隔为2秒。循环数定义了线程的运行时间。使用调度器，还可以设置运行的起始时间。
&lt;img src=&quot;/images/posts/tools/jmeter04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;新增http请求默认值&quot;&gt;新增http请求默认值&lt;/h4&gt;
&lt;p&gt;在上一步创建的线程组上，新增http请求默认值，所有的请求都会使用设置的默认值，这设置协议为http，IP为127.0.0.1，端口为8080
&lt;img src=&quot;/images/posts/tools/jmeter05.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/tools/jmeter06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;添加要压测的http请求&quot;&gt;添加要压测的http请求&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter07.png&quot; alt=&quot;&quot; /&gt;
下图第一个红框内的协议、IP、端口不需要设置，会使用步骤c中设置的默认值，只需设置请求路径Path即可，这里填入/index.html
&lt;img src=&quot;/images/posts/tools/jmeter08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;新增监听器用于查看压测结果&quot;&gt;新增监听器，用于查看压测结果&lt;/h4&gt;
&lt;p&gt;这里添加三种：聚合报告、图形结果、用表格查看结果，区别在于结果展现形式不同。
&lt;img src=&quot;/images/posts/tools/jmeter09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;点击运行按钮开始压测并查看结果&quot;&gt;点击运行按钮开始压测，并查看结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jmeter结果分析&quot;&gt;jmeter结果分析&lt;/h3&gt;
&lt;p&gt;采用Jmeter测试工具对web系统作的负载测试，得出的响应报表，数据比较难懂，现作一具体说明。&lt;/p&gt;

&lt;h4 id=&quot;图形报表&quot;&gt;图形报表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图表底部参数的含义如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;样本数目是总共发送到服务器的请求数。&lt;/li&gt;
  &lt;li&gt;最新样本是代表时间的数字,是服务器响应最后一个请求的时间。&lt;/li&gt;
  &lt;li&gt;吞吐量是服务器每分钟处理的请求数。&lt;/li&gt;
  &lt;li&gt;平均值是总运行时间除以发送到服务器的请求数。&lt;/li&gt;
  &lt;li&gt;中间值是代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值。&lt;/li&gt;
  &lt;li&gt;偏离表示服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;聚合报告&quot;&gt;聚合报告&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter12.png&quot; alt=&quot;&quot; /&gt;
图表含义说明如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Label: 说明是请求类型，如Http，FTP等请求。&lt;/li&gt;
  &lt;li&gt;#Samples: 也就是图形报表中的样本数目，总共发送到服务器的样本数目。&lt;/li&gt;
  &lt;li&gt;Average: 也就是图形报表中的平均值，是总运行时间除以发送到服务器的请求数。&lt;/li&gt;
  &lt;li&gt;Median: 也就是图形报表中的中间值，是代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值。&lt;/li&gt;
  &lt;li&gt;90%line: 是指90%请求的响应时间比所得数值还要小。&lt;/li&gt;
  &lt;li&gt;Min:是代表时间的数字,是服务器响应的最短时间。&lt;/li&gt;
  &lt;li&gt;Max: 是代表时间的数字,是服务器响应的最长时间。&lt;/li&gt;
  &lt;li&gt;Error%: 请求的错误百分比。&lt;/li&gt;
  &lt;li&gt;Throughput: 也就是图形报表中的吞吐量，这里是服务器每单位时间处理的请求数，注意查看是秒或是分钟。&lt;/li&gt;
  &lt;li&gt;Received KB/sec: 是每秒钟接收的字节数。&lt;/li&gt;
  &lt;li&gt;Send KB/sec: 是每秒钟请求的字节数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;html报表报告&quot;&gt;HTML报表报告&lt;/h4&gt;
&lt;p&gt;图中配置的所有数据写入文件test-jh.jtl，可通过命令模式将其数据生成html文档，命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cd apache-jmeter-5.0
# bin/jmeter.sh -g report/test-jh.jtl -e -o report/test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;打开生成的html（report/test/index.html）,结果如下：&lt;/p&gt;

&lt;h5 id=&quot;首页&quot;&gt;首页&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;apdexapplication-performance-index&quot;&gt;APDEX(Application Performance Index）&lt;/h6&gt;
&lt;p&gt;企业应用程序性能满意度标准，详见 &lt;a href=&quot;#apdex&quot;&gt;附录2 APDEX&lt;/a&gt;。&lt;/p&gt;

&lt;h6 id=&quot;requests-summary&quot;&gt;Requests Summary&lt;/h6&gt;
&lt;p&gt;样本请求的成功、失败百分占比图表。&lt;/p&gt;

&lt;h6 id=&quot;statistics&quot;&gt;Statistics&lt;/h6&gt;
&lt;p&gt;此部分结果展示的是每个样本事务的一些常见的性能测试指标，跟我们通常看到的聚合报告的表格展示非常相近，多了成功与失败的占比。&lt;/p&gt;

&lt;h6 id=&quot;errors&quot;&gt;Errors&lt;/h6&gt;
&lt;p&gt;执行结果的错误情况，根据不同的错误类型进行展示。
四列分别对应：发生错误的类型、错误数量、类型错误占比（相对于错误总数）、类型错误样本占比（相对于所有的请求样本数量）。&lt;/p&gt;

&lt;h5 id=&quot;图表&quot;&gt;图表&lt;/h5&gt;

&lt;h6 id=&quot;over-time&quot;&gt;Over Time&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Response Times Over Time
随时间推移，样本请求响应时间的变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response Time Percentiles Over Time (successful responses)
随时间变化的响应时间百分比（成功响应）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Active Threads Over Time
活动线程随着时间的推移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bytes Throughput Over Time
随时间的字节吞吐量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Latencies Over Time
随时间推移的延迟&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Connect Time Over Time
连接时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;throughput吞吐量&quot;&gt;Throughput(吞吐量)&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Hits Per Second
每秒点击次数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Codes Per Second
每秒代码数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Transactions Per Second
每秒事务数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Total Transactions Per Second
每秒总交易量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response Time Vs Request
响应时间与请求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Latency Vs Request
延迟与请求&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;response-times响应时间&quot;&gt;Response Times(响应时间)&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Response Time Percentiles
响应时间百分位数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response Time Overview
响应时间概述&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Time Vs Threads
时间与线程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response Time Distribution
响应时间分布&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;附录&quot;&gt;附录：&lt;/h3&gt;

&lt;h4 id=&quot;jmeter命令行参数&quot;&gt;Jmeter命令行参数&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/tools/jmeter_ps01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;apdex&quot;&gt;&lt;span id=&quot;apdex&quot;&gt;APDEX&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;是由 APDEX 公司推出的衡量企业应用程序性能满意度标准的计算方式。其将用户的满意度用数字衡量，范围在 0-1 之间。0表示所有用户均不满意，1表示所有用户都满意；随着满意度指数的增加，用户满意度逐步增加。设定请求样本目标响应时间为t，则可容忍的响应时间设定为目标响应时间t的4倍（即为4t）。公式定义为：（满意的样本数量 + 可容忍样本数量的一半） / 总样本数量。 计算公式如下：
&lt;img src=&quot;/images/posts/tools/jmeter_ps11.png&quot; alt=&quot;&quot; /&gt;
例如：总样本数量为 1000，目标时间t=3s，750个样本响应时间小于等于t，150个样本响应时间在3s-12s之间，100个样本响应时间超过12s，则用户满意度为：
&lt;img src=&quot;/images/posts/tools/jmeter_ps12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/jmeter/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/jmeter/</guid>
        
        <category>压力测试</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>IntelliJ IDEA使用小技巧</title>
        <description>&lt;p&gt;IntelliJ IDEA使用小技巧&lt;/p&gt;

&lt;h3 id=&quot;解决idea工具下tomcat中文乱码问题&quot;&gt;解决idea工具下tomcat中文乱码问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在运行/调试 配置对话框的Startup/Connection面板中，勾选Pass environment variables
并添加一个environment variable，Name填 JAVA_TOOL_OPTIONS, Value填 -Dfile.encoding=UTF-8&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/tools/idea-tomcat.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/idea_skill/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/idea_skill/</guid>
        
        <category>IntelliJIDEA</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>linux服务器架设Nginx</title>
        <description>&lt;p&gt;linux服务器架设Nginx&lt;/p&gt;

&lt;h3 id=&quot;安装nginx服务&quot;&gt;安装Nginx服务&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;添加源：默认情况Centos7中无Nginx的源，但是Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;安装Nginx&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install -y nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;启动Nginx并设置开机自动运行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl start nginx.service
sudo systemctl enable nginx.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;配置nginx&quot;&gt;配置Nginx&lt;/h3&gt;

&lt;p&gt;Nginx全局配置 /etc/nginx/nginx.conf
自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/&lt;/p&gt;

&lt;p&gt;网站文件存放默认目录 /usr/share/nginx/html
网站默认站点配置 /etc/nginx/conf.d/default.conf&lt;/p&gt;

&lt;h4 id=&quot;nginx启动&quot;&gt;Nginx启动&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nginx重启&quot;&gt;Nginx重启&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nginx检查配置文件&quot;&gt;Nginx检查配置文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -t
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 18 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/linux_nginx/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/linux_nginx/</guid>
        
        <category>linux</category>
        
        <category>Nginx</category>
        
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
